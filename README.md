# Hello Slack! üëãüèΩ

## Overview

I've put together a small project that does several things:

- Accepts searches which end up hitting the [Flickr API](https://www.flickr.com/services/api/flickr.photos.search.html).

- Adds a list of photo search results displayed in a grid.

- Pops up a lightbox-style viewer that includes previous/next buttons and keyboard handling.

- Loads in subsequent pages of results upon scrolling to the bottom of the page.

I decided to keep the UI relatively simple to avoid using up too much time and/or going outside the scope of the exercise, but I have listed some additional things I'd want to add/change given more time down below.

## Quick setup

You should not, to my knowledge, have to install any packages globally (which I try to avoid). Inside the repo directory run:

```
npm install
npm run start
```

This will startup a webpack development server which will be available at `http://localhost:8080` (if that doesn't work, check your default port and use that instead of 8080.)

To run the unit tests, run `npm run test`.

To build an unminified version of `bundle.js` and `style.css` with source maps, run `npm run build`.

To build a minified production version of `bundle.js` and `style.css`, run `npm run build-prod`.

## Tool choices

I evaluate all tool/pattern choices on a few general axes:

- Developer experience (a combination of ease-of-use and potential for productivity boost).

- Popularity/support/shared knowledge within the broader community (it's no fun being the _only_ one relying on an open source package to serve paying customers).

- Cost of setup and maintenance vs. value generated by use.

### Build tools & preprocessors

- [webpack](https://webpack.github.io/) for processing and bundling assets. I would've gone with [rollup](https://rollupjs.org/) due to the significant performance advantages of its JS compilation strategy, but I'm far more familiar with the setup and configuration for webpack and didn't want to risk using up too much time.

- [Babel](https://babeljs.io/) for consistent, cross-platform ES2015/16/17 features.

- [PostCSS](http://postcss.org/) for a couple of basic code-organization features ([variables](https://github.com/postcss/postcss-custom-properties) and [composition](https://github.com/travco/postcss-extend)).

- [PhantomJS](http://phantomjs.org/), [Karma](https://karma-runner.github.io/1.0/index.html), [Mocha](https://mochajs.org/), [Chai](http://chaijs.com/), and [Sinon](http://sinonjs.org/) for unit tests. I chose this particular testing stack because 1) I'm already intimately familiar with it and 2) I quite like it üòÅ. If I had time for more exploratory/experimental work I would've probably tried out [Jest](https://facebook.github.io/jest/) since I have enjoyed using it in the past, but I'm not familiar with its setup enough to feel comfortable on a shorter schedule.

### Polyfills

- I used the `object-fit` CSS property for a couple of things, which needs to be polyfilled for the current stable version of Edge (though the upcoming version will include support). There are a couple of existing polyfills ([here](https://github.com/bfred-it/object-fit-images), [here](https://github.com/constancecchen/object-fit-polyfill), and [here](https://github.com/anselmh/object-fit)), but they are all either deprecated/decaying or don't fully support the dynamic-loading use case this project includes. As a result, I ended up writing my own very small polyfill that can be called from JS code when an image's `src` has changed. This custom polyfill is very use-case-specific and requires explicit use in application code, and while it serves its purpose well for this project I would not want to use it for a larger scale app. If I wanted to use `object-fit` in a larger app I would either go in and figure out how to add support for my use case to one of the existing polyfills or expand the one I included here to be more general-purpose and get the job done without explicit calls from application code.

- Because `fetch` is supported in the current stable versions of Chrome, Firefox, Safari, and Edge, I did not polyfill it. If I wanted to support a larger share of browsers I would include the `whatwg-fetch` polyfill.

- Similar to `fetch`, all of the CSS properties I used are supported un-prefixed in the latest stable browser versions with the exception of `object-fit`. If I needed to support prefixing I would add [autoprefixer](https://github.com/postcss/autoprefixer) to my PostCSS config.

## Code organization / design choices

### API client

I decided to split the API layer into a few composable components:

- There is a lower-level `flickrAPI` module which talks directly to `fetch`, and accepts any options you care to give it. This could be used for many other purposes besides photo searching if the app were to expand to other use cases.

- There is a search-specific `flickrSearchAPI` module which makes it more expressive to write search API calls. This is a super thin wrapper that is mostly for convenience/readability, and it also provides the opportunity to specify per-client options which can be overridden on a per-request basis (I have found this pattern super useful in areas where you have really-similar-but-not-quite-the-same API calls).

- Lastly, there's `flickrSearchAPIAdapter`. This is meant to map Flickr's API response into something that is more finely tuned to the needs of the app in general. Part of why I pulled this into its own module rather than doing the transformation in the place where the API client is called is to make it easier to add other API sources (i.e. google, giphy, etc.) without changing much view-layer code. It'd be pretty simple to add another API client, kickoff a search on both clients, and then have them both return the same normalized data structure through their own adapters.

### Views

There are a few views, which I implemented as classes that contain a couple common methods:

- `getElement()` returns the outermost DOM element, which allows the calling code to add the DOM-output of a view to whatever container element makes the most sense for the use case (the only view that doesn't work this way is `App`, because that view is not really reusable and is meant to be a root-level view.)

- `destroy()` cleans up references, removes listeners, and removes elements from the DOM. In this project none of the `destroy()` methods ever get called because the photo search UI is the entirety of the app, but if another section were to be added (a popular or recent list for example), then the search UI would need to be destroyed.

There are 4 views:

- `App` handles the data-fetching and orchestration of sub views. In a more substantial UI some of `App`'s functionality would move out to other modules, but for its current state handling everything inside `App` makes things easier to read and understand.

- `SearchForm` creates a typical search form with what I consider the 'standard' set of UX conveniences, namely:
  - Placeholder text to hint at usage.
  - Searching on enter/return press.
  - Automatic disabling/enabling of search depending on whether or not
  there is text in the input field (this is throttled to avoid doing too much work on key presses).
  - The ability to focus the input field as desired.

- `PhotoList` handles displaying a list of photos (styled as a grid in this case) that is loaded in asynchronously. Photos can be rendered to the page via the `setPhotos()` method, which clears away previous photos upon use. A few things to note about `PhotoList.setPhotos()`:
  - It will happily accept a single, static __object__ with photo info and display it without any bells/whistles (i.e. async loading and infinite scroll are not required.)
  - If given a __Promise__, it will show a placeholder loading 'skeleton' in place of actual images until the data comes in, after which it will setup the placeholder images with their new corresponding data and add new images if there are more photos in the data than the number of placeholders (I chose to mutate the placeholder images instead of replacing them to avoid extraneous DOM work, since that is quite slow).
  - If given a __function__, it will call that function with a page number of `1` to render the first set of images. This function can either return an __object__ or a __Promise__. When the user scrolls within a certain distance of the bottom of the page it will show another set of placeholder images, call the function again with `2` in order to get the next page of photos, and load in the next set of images. This is effectively 'infinite scroll', but the data passed into `PhotoList` should include a page number and a total number of pages so that it can stop trying to load more once it's reached the last page.
  - I chose to allow external callers to specify a callback for when a photo is about to be mounted to the DOM. It is passed the `Image` element that will be rendered along with the specific photo's data from the list. I could've put this inside `PhotoList` itself, but I wanted to leave flexibility for other use cases and data structures (right now all that `PhotoList` requires is an object with a page number, total number of pages, items per page, and a `photos` property with an array of objects with any internal shape.)

- `Lightbox` is a general-purpose lightbox-style photo viewer. It accepts two different ways of showing a photo, either listening for clicks on elements with user-specified DOM attributes or calling the `show()` method with a URL. In order to support previous/next photo behavior it requires that you provide an array of objects with the shape `{title: string, url: string}` via the `setPhotos()` method. For use-cases like infinite scroll you can also append photos to the end of the list via `addPhotos()`. Both methods accept either an __object__ or a __Promise__. `Lightbox` also handles keyboard events for previous, next, and close.

### Unit tests

I added unit tests for the API clients/adapters, along with the helper modules that don't interact with the DOM. Because the hand-written DOM manipulation code for views doesn't isn't that straightforward to test (as opposed to something like React that can spit out a string or easily analyzable data structure) I avoided testing them for now.

### What about mobile?

This project doesn't have great mobile support because I didn't feel that was a great use of time for this project. If I had more time I'd add some better styling (like making the lightbox take up the full screen on smaller size windows) and add touch event support for swiping through the lightbox. I'd also most likely need to polyfill a few things that aren't supported on all stable mobile browsers yet. Nothing about the current setup would make it particularly difficult to add better mobile support.

## Things I would add/change

If I had more time to devote to this I'd most likely add:

- Integration tests with something like Selenium.

- The ability to search other public APIs besides Flickr.

- Sorting based on factors besides popularity/interestingness.

- A fullscreen mode for `Lightbox`.

- More style/animation polish.
